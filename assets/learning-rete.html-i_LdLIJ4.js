import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a,b as o,d as l,o as n}from"./app-CdpNCDY8.js";const i="/assets/rete-Dpf-XatM.png",s={};function p(c,e){return n(),r("div",null,[e[0]||(e[0]=a("p",null,"在规则世界里，RETE算法应该是无人不晓了，许多有名的规则引擎或者专家系统都是基于RETE算法实现的，包括Jess，JRules，Drools，CLIPS等。",-1)),o(" more "),e[1]||(e[1]=l('<h2 id="算法简介" tabindex="-1"><a class="header-anchor" href="#算法简介"><span>算法简介</span></a></h2><p>引用下wiki上关于<a href="http://en.wikipedia.org/wiki/Rete_algorithm" title="RETE algorithm" target="_blank" rel="noopener noreferrer">RETE算法</a>的定义：</p><blockquote><p>RETE（/&#39;ri:ti:/ or /&#39;reiti:/）算法是个高效的可用于实现规则产生式系统（一种计算机程式，一般用于提供某种形式的人工智能，主要由基于行为的一系列规则构成）的模式匹配算法。</p></blockquote><p>简而言之就是一套规则匹配优化算法。这个算法最早出现在1974年Dr Charles L. Forgy的一篇工作报告中，随后在1979年他的博士论文中完善，然后是1982年在《人工智能》杂志上的一篇<a href="http://www.csl.sri.com/users/mwfong/Technical/RETE%20Match%20Algorithm%20-%20Forgy%20OCR.pdf" title="RETE MATCH" target="_blank" rel="noopener noreferrer">文章</a>。</p><h2 id="原理简介" tabindex="-1"><a class="header-anchor" href="#原理简介"><span>原理简介</span></a></h2><p>现实中，如果要实现一个由若干规则组成的系统？最原始的做法大致应该是（类似krrules，囧）：匹配第一条规则，再匹配下一条规则，直到所有规则匹配完毕。这样的规则匹配时间就应该是与规则数量呈线性关系：即随着规则数目的增多，规则的匹配时间线性增长。而在一些由大量规则构成的专家系统（Expert System）中，这样的规则匹配效率达不到要求，这促使了RETE的诞生。</p><h3 id="名词解释" tabindex="-1"><a class="header-anchor" href="#名词解释"><span>名词解释</span></a></h3><p>有几个名词在描述RETE时会用到，他们大致是这些：</p><ol><li>facts:指RETE网络中的输入项，数据元祖（data tuples）。</li><li>rule:指用于对facts进行模式匹配的条件设置。</li><li>action：指满足规则匹配后的动作处理。</li><li>production:由一个或多个规则加上一系列动作构成。</li><li>WME:当facts被插入引擎，即为它们创立（working memory elements）。</li></ol><h3 id="匹配流程" tabindex="-1"><a class="header-anchor" href="#匹配流程"><span>匹配流程</span></a></h3><figure><img src="'+i+'" alt="Drools RETEOO" tabindex="0" loading="lazy"><figcaption>Drools RETEOO</figcaption></figure><p>参考上图，一个完整的RETE规则匹配流程大致是这样的：</p><ol><li>一个或多个事实facts被assert进RETE规则网络，</li><li>网络根据配置的规则rules进行模式匹配，并为facts创建WMEs，</li><li>对于触发规则的facts创建activitions并放入agenda中，</li><li>agenda根据触发规则优先级salience确立触发次序，</li><li>最后执行action。</li></ol><h3 id="节点分类" tabindex="-1"><a class="header-anchor" href="#节点分类"><span>节点分类</span></a></h3><p>最初Dr Charles L. Forgy提出的RETE网络是由四种节点构成，分别为：</p><ul><li>root node（输入起始节点）</li><li>one-input node（单fact的条件匹配）</li><li>two-input node（多facts的联合join）</li><li>terminal node（走到此节点，则规则匹配）</li></ul><p>人们在算法实现时又常常将one-input node再细分为：</p><ul><li>Type Node：定位事实属性，确定fact的class，在krrules实现时将此步称为确定所属数据源，这为后续的节点定义和操作做好了铺垫；</li><li>Alpha Node：对fact的属性进行匹配判断，比如对一个person的fact，判断其age是否大于18，gender是否为male等；</li><li>Beta Node：则相对更为复杂一些，需要实现了两个fact的关联与匹配（比如一个person是否出现在一次party人员名单中）。 具体的节点和功能作用，此处不再赘述了，想要更详细的了解rete算法的同学，除了阅读上面的原作者论文，还可参考这篇文章：<a href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" target="_blank" rel="noopener noreferrer">《Production Matching For Large Learning Systems》</a>，有好几十页的篇幅详细的介绍了RETE算法。</li></ul><h2 id="算法总结" tabindex="-1"><a class="header-anchor" href="#算法总结"><span>算法总结</span></a></h2><p>以上，可以发现RETE的优点在于：</p><ol><li>通过节点共享（node sharing）减少了规则中重复模式（pattern）的计算；</li><li>存储了部分匹配fact联合join匹配的结果，这样当facts少量变化时，免去未变化的计算量。</li></ol><p>了解优点后，我们也很容易总结发现RETE相对于传统的线性匹配的优势点或优化场景在于：<br><strong>大量规则（规则间具有某些重复pattern的情况），少量变化（规则判定的facts不是每次都重新assert）</strong><br> 在这样的场景下RETE规则匹配算法会得到更好的效果，这对规则的设计与开发者是有些指导意义的。</p><h2 id="应用案例" tabindex="-1"><a class="header-anchor" href="#应用案例"><span>应用案例</span></a></h2><p>RETE在诞生以后，被广泛的用于专家系统和规则引擎的构建中，其中著名的有：</p><ul><li>专家系统<a href="http://clipsrules.sourceforge.net/" title="CLIPS" target="_blank" rel="noopener noreferrer">CLIPS</a>：源于1984年NASA的人工智能项目，现已开源，由C编写，简单看过源码，逻辑组织还是比较清晰的，后面详细阅读过源码后，有机会再专门介绍下。</li><li>规则引擎<a href="http://www.jboss.org/drools/" title="drools" target="_blank" rel="noopener noreferrer">Drools</a>：现在是jboss的开源项目，现已被广泛应用到各商业产品的开发中，drools文档中有关于RETE的实现RETEOO通俗易懂的介绍，可参考：<a href="http://docs.jboss.org/drools/release/6.0.0.Beta5/drools-expert-docs/html/ch01.html#d0e515" target="_blank" rel="noopener noreferrer">http://docs.jboss.org/drools/release/6.0.0.Beta5/drools-expert-docs/html/ch01.html#d0e515</a></li></ul>',25))])}const g=t(s,[["render",p]]),m=JSON.parse(`{"path":"/blog/learning-rete.html","title":"RETE算法初窥","lang":"zh-CN","frontmatter":{"title":"RETE算法初窥","tag":["rete","rule","Drools"],"category":["learning"],"date":"2013-07-28T16:58:24.000Z","description":"在规则世界里，RETE算法应该是无人不晓了，许多有名的规则引擎或者专家系统都是基于RETE算法实现的，包括Jess，JRules，Drools，CLIPS等。","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RETE算法初窥\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2013-07-28T16:58:24.000Z\\",\\"dateModified\\":\\"2025-11-15T10:21:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"abstiger\\",\\"url\\":\\"https://abstiger.com\\"}]}"],["meta",{"property":"og:url","content":"https://abstiger.com/blog/learning-rete.html"}],["meta",{"property":"og:site_name","content":"Tiger's Website"}],["meta",{"property":"og:title","content":"RETE算法初窥"}],["meta",{"property":"og:description","content":"在规则世界里，RETE算法应该是无人不晓了，许多有名的规则引擎或者专家系统都是基于RETE算法实现的，包括Jess，JRules，Drools，CLIPS等。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-15T10:21:25.000Z"}],["meta",{"property":"article:tag","content":"Drools"}],["meta",{"property":"article:tag","content":"rule"}],["meta",{"property":"article:tag","content":"rete"}],["meta",{"property":"article:published_time","content":"2013-07-28T16:58:24.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-15T10:21:25.000Z"}]]},"git":{"createdTime":1763202085000,"updatedTime":1763202085000,"contributors":[{"name":"mingqiang.cheng","username":"","email":"mingqiang.cheng@cloudpense.com","commits":1}]},"readingTime":{"minutes":4.19,"words":1256},"filePathRelative":"blog/learning-rete.md","excerpt":"<p>在规则世界里，RETE算法应该是无人不晓了，许多有名的规则引擎或者专家系统都是基于RETE算法实现的，包括Jess，JRules，Drools，CLIPS等。</p>\\n","autoDesc":true}`);export{g as comp,m as data};
