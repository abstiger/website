---
order: 1
title: krproject开发进展（一）
article: false  
date: 2012-04-07 21:34:40
---

有一个多月没有写博了，这段时间除了一些日常的工作外，就是在设计规划和开发krproject，想给krproject一个明确一点的定位，这个系统或者这个项目到底是要做什么？

一句话总结是：**基于大数据量的实时流数据分析系统**。

`大数据量`：这当然是个噱头了；

`实时`：不仅要求系统提供服务模式，还要保证系统处理的性能与效率；

`流`：限制要求输入数据为流式，实际上如果去除物理存储的限制，我相信所有的数据库都会是流式的，记录随时间流逝所发生的一切，没有删除也不会更新，日志即记录~

`数据分析`：这一块考虑分成两个方向：一个是基于规则的；另一个是基于机器学习的。

我目前接触到的一些产品似乎都将人们的目光聚集在“数据分析”上了，实际上以我目前的理解，我觉得这样一个系统性能的关键并不在数据分析上，而是在数据分析前的数据准备上：怎样高效的组织存储输入数据和如何高效计算获取数据分析所需要的统计量。

机器学习我了解的还不是很多，粗浅的认为机器学习的输入数据不应该只是当笔的流水信息，这样首先很难对非数字类型的数据归一化，其次我觉得那样的训练模型应该很难满足数据挖掘或分析的要求，它也应该需要之前的数据准备和加工。

废话不多说，介绍下krproject的设计与进展，目前暂不考虑神经网络了，系统大致会分为以下几个模块：

**基础模块krutils**（Done）：

包括内存分配器，日志记录，配置文件解析，一些基础数据结构：动态hash table（glib中剥离），双向循环链表list（为了尽力遵循ansi c标准，还是舍弃了从kernel中扒出来双向循环链表实现，因为它里面含有gcc特有的typeof……，hp-ux上的aCC并不支持），scoket操作（采用redis中的anet，支持unix域通信与tcp/ip），事件驱动机制（采用redis中的ae）；

**数据库操作模块krdbs**（Doing）：

krproject应该是nosql与关系型数据库结合的最佳典范了，哈哈。一些配置信息（数据源、统计量、规则等）和流水记录还是会放到传统的关系型数据库中，所以需要有这样一个模块完成关系型数据库的接口处理层。目前考虑支持DB2和Oracle，目前这两个数据库都有装到我的虚拟机里了，这两天正在看如何通过gnu的autotools实现这两个数据库的编译识别（这里并不是采用数据库复杂的底层C接口，而是我以前写的嵌入式sql-C转换工具gensql）；

**共享内存模块krshm**（TODO）：

主要是保证这些配置信息的更改实时生效，所以会将一些配置和控制信息放入共享内存中，以实现配置信息更改的无缝切换与实时生效；

**内存数据存储模块krdb**（TODO）：

原有代码的优化，简单的通过mmap增加内存的持久化与加载功能；

**规则运算模块krrules**（TODO）：

完善之前的初稿，优化规则的运算，同时增加统计信息的缓存：包括记录级缓存（主要是指一次交易处理的规则运算中，如果遇到相同的统计量，如5分钟内的登录次数，半小时内的股票买入总量等，第二次无须计算，直接取值，考虑采用hash table实现）与触发性缓存（有些统计量需要结合外部输入的统计信息的，比如5天交易总笔数、6个月月平均交易总金额等，这些信息需要结合批量运算，一天才更新一次，考虑采用设置超时事件模式）；

**集成与服务化模块krserver**（TODO）：

main函数了，配置文件解析，进程的守护化，数据库连接，共享内存attach，建立与协调器的连接，网络端口的监听，事件的注册与处理。考虑采用半同步半异步的方式分离流水处理的krdb插入与krrules计算，因为krdb需要保证数据的先后且理论上时间很短，而随着规则的复杂，krrules的运算消耗将是大头，分离他们应该会有效提升效率；

**集群与协调器krcoordinator**(TODO):

本打算采用zeromq完成网络层的包装和集群的实现，可是在hp-ux上编译zeromq时还是遇到了不少问题，另也觉得zeromq对scoket的一些包装有些过了，可能在遇到问题时很难调试和解决，还有就是我想尽量介绍第三方依赖。集群的实现就不考虑什么paxos算法了，太复杂了……，另外就是一般商用的集群也不会很多，两三台就很牛了。还是容易实现和理解的客户端->协调器->服务器模式，客户端统一连接到协调器上，协调器根据采用一致性hash算法决定哪一台服务器执行此笔记录的规则运算在报文记录头增加该机器标识，而协调器会给所有连接上的服务器发送记录，服务端都执行krdb的插入，而根据报文头确定是否由自己来执行krrules的运算，这么做的主要目的是图简单啦，省掉节点间replication了；

**客户端模块krclient**（TODO）：

包装客户端的调用接口，目前只考虑C的调用接口了，也许以后会增加各种语言的调用接口~

如果您想了解更多、觉得设计有些问题、有什么好的建议或意见，统统给我留言吧~
